// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)

#if CODEGEN
namespace Rainbow
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.IO;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <content>
    /// Contains code pertaining to C++ interop.
    /// </content>
    /// <remarks>
    /// To build the bindings generator, define <c>CODEGEN</c> and compile with
    /// <c>emitEntryPoint</c> set to <c>true</c>.
    /// </remarks>
    public sealed partial class Program
    {
        private static IReadOnlyDictionary<string, string> ClassNameDictionary { get; } =
            new Dictionary<string, string>
            {
                ["fontatlas"] = "FontAtlas",
                ["renderqueue"] = "RenderQueue",
                ["spritebatch"] = "SpriteBatch",
                ["textureatlas"] = "TextureAtlas",
            };

        private static Regex FunctionRegex { get; } =
            new Regex(@"^RAINBOW_API ([*:\w]+)\s+rainbow_([0-9a-z_]+)\((.*?)\);", RegexOptions.Compiled);

        private static Regex NamelessParameterRegex { get; } =
            new Regex(@"\s?([*\s\w]+)$", RegexOptions.Compiled);

        private static Regex ParameterRegex { get; } =
            new Regex(@"\s?([*\s\w]+)\s(\w+)$", RegexOptions.Compiled);

        private static IReadOnlyDictionary<string, string> TypeDictionary { get; } =
            new Dictionary<string, string>
            {
                ["bool"] = "bool",
                ["const char*"] = "[MarshalAs(UnmanagedType.LPUTF8Str)] string",
                ["const int32_t*"] = "int[]",
                ["const uint32_t*"] = "uint[]",
                ["float"] = "float",
                ["int32_t"] = "int",
                ["rbAnimationEventHandler"] = "[MarshalAs(UnmanagedType.FunctionPtr)] AnimationEventHandler",
                ["rbColor"] = "Color",
                ["rbVec2"] = "Vector2",
                ["TextAlignment"] = "TextAlignment",
                ["uint32_t"] = "uint",
                ["void"] = "void",
                ["void*"] = "IntPtr",
            };

        /// <summary>
        /// Generates C# explicit PInvoke (DllImport) declarations by performing
        /// naive regex matching over include/Rainbow.hpp.
        /// </summary>
        public static void Main()
        {
            var stringBuilder = new StringBuilder(1024);

            using (var fileReadStream = new FileStream(@"../../include/Rainbow.hpp", FileMode.Open, FileAccess.Read))
            using (var streamReader = new StreamReader(fileReadStream))
            using (var fileWriteStream = new FileStream(@"Interop/Core.cs", FileMode.Create, FileAccess.Write))
            using (var fileWriter = new StreamWriter(fileWriteStream, new UTF8Encoding(false)) { NewLine = "\n" })
            {
                fileWriter.WriteLine(@"// This file was generated by Rainbow for .NET Core. Do not modify.");
                fileWriter.WriteLine(@"//");
                fileWriter.WriteLine($"// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen");
                fileWriter.WriteLine(@"// Distributed under the MIT License.");
                fileWriter.WriteLine(@"// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)");
                fileWriter.WriteLine();
                fileWriter.WriteLine(@"namespace Rainbow.Interop");
                fileWriter.WriteLine(@"{");
                fileWriter.WriteLine(@"    using System;");
                fileWriter.WriteLine(@"    using System.Runtime.InteropServices;");
                fileWriter.WriteLine();
                fileWriter.WriteLine(@"    using Graphics;");
                fileWriter.WriteLine();
                fileWriter.WriteLine(@"    internal static class Core");
                fileWriter.WriteLine(@"    {");
                fileWriter.WriteLine(@"        private const string RainbowCore = @""rainbow.exe"";");

                string line;
                while ((line = streamReader.ReadLine()) != null)
                {
                    var match = FunctionRegex.Match(line.Replace(@"rainbow::", string.Empty));
                    if (!match.Success || match.Groups.Count != 4)
                    {
                        continue;
                    }

                    string returnType = GetManagedType(match.Groups[1].Value);
                    string entryPoint = match.Groups[2].Value;

                    fileWriter.WriteLine();
                    fileWriter.WriteLine($"        [DllImport(RainbowCore, EntryPoint = @\"rainbow_{entryPoint}\")]");

                    stringBuilder.Clear();
                    foreach (var str in entryPoint.Split('_'))
                    {
                        string customName;
                        if (ClassNameDictionary.TryGetValue(str, out customName))
                        {
                            stringBuilder.Append(customName);
                        }
                        else
                        {
                            stringBuilder.Append(char.ToUpperInvariant(str[0]));
                            stringBuilder.Append(str.Substring(1));
                        }
                    }

                    string funcName = stringBuilder.ToString();
                    stringBuilder.Clear();

                    char uniqueName = 'o';
                    foreach (var str in match.Groups[3].Value.Split(','))
                    {
                        var paramMatch = ParameterRegex.Match(str);
                        if (paramMatch.Success)
                        {
                            var typeName = GetManagedType(paramMatch.Groups[1].Value);
                            var paramName = paramMatch.Groups[2].Value;
                            stringBuilder.Append($"{typeName} {paramName}, ");
                        }
                        else
                        {
                            paramMatch = NamelessParameterRegex.Match(str);
                            if (paramMatch.Success)
                            {
                                var typeName = GetManagedType(paramMatch.Groups[1].Value);
                                stringBuilder.Append($"{typeName} {++uniqueName}, ");
                            }
                        }
                    }

                    if (stringBuilder.Length > 2)
                    {
                        stringBuilder.Remove(stringBuilder.Length - 2, 2);
                    }

                    string args = stringBuilder.ToString();
                    fileWriter.WriteLine($"        public static extern {returnType} {funcName}({args});");
                }

                fileWriter.WriteLine(@"    }");
                fileWriter.WriteLine(@"}");
            }
        }

        [Pure]
        private static string GetManagedType(string type)
        {
            string managedType;
            if (TypeDictionary.TryGetValue(type, out managedType))
            {
                return managedType;
            }

            Contract.Assert(type.EndsWith(@"*", StringComparison.Ordinal), $"Expected a pointer type, got {type}.");
            return TypeDictionary[@"void*"];
        }
    }
}
#endif
