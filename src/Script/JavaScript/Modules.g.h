// This file was generated by `generate-bindings.ts`. DO NOT MODIFY!
//
// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)

#ifndef SCRIPT_JAVASCRIPT_MODULES_H_
#define SCRIPT_JAVASCRIPT_MODULES_H_

#include <Rainbow/AnimationEvent.h>
#include <Rainbow/TextAlignment.h>
#include "Audio/Mixer.h"
#include "Common/TypeCast.h"
#include "Common/TypeInfo.h"
#include "Graphics/Animation.h"
#include "Graphics/Label.h"
#include "Graphics/RenderQueue.h"
#include "Graphics/Sprite.h"
#include "Graphics/SpriteBatch.h"
#include "Graphics/Texture.h"
#include "Input/Controller.h"
#include "Input/Input.h"
#include "Input/VirtualKey.h"
#include "Script/JavaScript/Helper.h"

#ifdef __GNUC__
#    pragma GCC diagnostic push
#    pragma GCC diagnostic ignored "-Wold-style-cast"
#endif

// clang-format off

template <>
void rainbow::duk::register_module<rainbow::Animation>(duk_context* ctx, duk_idx_t rainbow)
{
    duk::push_constructor<Animation, SpriteRef, Animation::Frames, uint32_t, int>(ctx);
    duk::put_prototype<Animation, Allocation::HeapAllocated>(ctx, [](duk_context* ctx) {
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto result = obj->current_frame();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "currentFrame");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto result = obj->frame_rate();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "frameRate");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto result = obj->sprite();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "sprite");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto args = duk::get_args<Animation::Callback>(ctx);
                obj->set_callback(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setCallback");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto args = duk::get_args<int>(ctx);
                obj->set_delay(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setDelay");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto args = duk::get_args<uint32_t>(ctx);
                obj->set_frame_rate(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setFrameRate");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto args = duk::get_args<Animation::Frames>(ctx);
                obj->set_frames(std::move(std::get<0>(args)));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setFrames");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto args = duk::get_args<SpriteRef>(ctx);
                obj->set_sprite(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setSprite");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                auto args = duk::get_args<uint32_t>(ctx);
                obj->jump_to(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "jumpTo");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                obj->rewind();
                return 0;
            },
            0);
        duk::put_prop_literal(ctx, -2, "rewind");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                obj->start();
                return 0;
            },
            0);
        duk::put_prop_literal(ctx, -2, "start");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Animation>(ctx);
                obj->stop();
                return 0;
            },
            0);
        duk::put_prop_literal(ctx, -2, "stop");
        duk::push_literal(ctx, "Rainbow.Animation");
        duk::put_prop_literal(ctx, -2, DUKR_WELLKNOWN_SYMBOL_TOSTRINGTAG);
    });
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "Animation");
}

template <>
void rainbow::duk::register_module<rainbow::AnimationEvent>(duk_context* ctx, duk_idx_t rainbow)
{
    const auto obj_idx = duk_push_bare_object(ctx);
    duk_push_int(ctx, to_underlying_type(AnimationEvent::Start));
    duk::put_prop_literal(ctx, obj_idx, "Start");
    duk_push_int(ctx, to_underlying_type(AnimationEvent::End));
    duk::put_prop_literal(ctx, obj_idx, "End");
    duk_push_int(ctx, to_underlying_type(AnimationEvent::Complete));
    duk::put_prop_literal(ctx, obj_idx, "Complete");
    duk_push_int(ctx, to_underlying_type(AnimationEvent::Frame));
    duk::put_prop_literal(ctx, obj_idx, "Frame");
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "AnimationEvent");
}

template <>
void rainbow::duk::register_module<rainbow::ControllerAxis>(duk_context* ctx, duk_idx_t rainbow)
{
    const auto obj_idx = duk_push_bare_object(ctx);
    duk_push_int(ctx, to_underlying_type(ControllerAxis::Invalid));
    duk::put_prop_literal(ctx, obj_idx, "Invalid");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::LeftX));
    duk::put_prop_literal(ctx, obj_idx, "LeftX");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::LeftY));
    duk::put_prop_literal(ctx, obj_idx, "LeftY");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::RightX));
    duk::put_prop_literal(ctx, obj_idx, "RightX");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::RightY));
    duk::put_prop_literal(ctx, obj_idx, "RightY");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::TriggerLeft));
    duk::put_prop_literal(ctx, obj_idx, "TriggerLeft");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::TriggerRight));
    duk::put_prop_literal(ctx, obj_idx, "TriggerRight");
    duk_push_int(ctx, to_underlying_type(ControllerAxis::Count));
    duk::put_prop_literal(ctx, obj_idx, "Count");
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "ControllerAxis");
}

template <>
void rainbow::duk::register_module<rainbow::ControllerButton>(duk_context* ctx, duk_idx_t rainbow)
{
    const auto obj_idx = duk_push_bare_object(ctx);
    duk_push_int(ctx, to_underlying_type(ControllerButton::Invalid));
    duk::put_prop_literal(ctx, obj_idx, "Invalid");
    duk_push_int(ctx, to_underlying_type(ControllerButton::A));
    duk::put_prop_literal(ctx, obj_idx, "A");
    duk_push_int(ctx, to_underlying_type(ControllerButton::B));
    duk::put_prop_literal(ctx, obj_idx, "B");
    duk_push_int(ctx, to_underlying_type(ControllerButton::X));
    duk::put_prop_literal(ctx, obj_idx, "X");
    duk_push_int(ctx, to_underlying_type(ControllerButton::Y));
    duk::put_prop_literal(ctx, obj_idx, "Y");
    duk_push_int(ctx, to_underlying_type(ControllerButton::Back));
    duk::put_prop_literal(ctx, obj_idx, "Back");
    duk_push_int(ctx, to_underlying_type(ControllerButton::Guide));
    duk::put_prop_literal(ctx, obj_idx, "Guide");
    duk_push_int(ctx, to_underlying_type(ControllerButton::Start));
    duk::put_prop_literal(ctx, obj_idx, "Start");
    duk_push_int(ctx, to_underlying_type(ControllerButton::LeftStick));
    duk::put_prop_literal(ctx, obj_idx, "LeftStick");
    duk_push_int(ctx, to_underlying_type(ControllerButton::RightStick));
    duk::put_prop_literal(ctx, obj_idx, "RightStick");
    duk_push_int(ctx, to_underlying_type(ControllerButton::LeftShoulder));
    duk::put_prop_literal(ctx, obj_idx, "LeftShoulder");
    duk_push_int(ctx, to_underlying_type(ControllerButton::RightShoulder));
    duk::put_prop_literal(ctx, obj_idx, "RightShoulder");
    duk_push_int(ctx, to_underlying_type(ControllerButton::DPadUp));
    duk::put_prop_literal(ctx, obj_idx, "DPadUp");
    duk_push_int(ctx, to_underlying_type(ControllerButton::DPadDown));
    duk::put_prop_literal(ctx, obj_idx, "DPadDown");
    duk_push_int(ctx, to_underlying_type(ControllerButton::DPadLeft));
    duk::put_prop_literal(ctx, obj_idx, "DPadLeft");
    duk_push_int(ctx, to_underlying_type(ControllerButton::DPadRight));
    duk::put_prop_literal(ctx, obj_idx, "DPadRight");
    duk_push_int(ctx, to_underlying_type(ControllerButton::Count));
    duk::put_prop_literal(ctx, obj_idx, "Count");
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "ControllerButton");
}

template <>
void rainbow::duk::register_module<rainbow::Label>(duk_context* ctx, duk_idx_t rainbow)
{
    duk::push_constructor<Label>(ctx);
    duk::put_prototype<Label, Allocation::HeapAllocated>(ctx, [](duk_context* ctx) {
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto result = obj->alignment();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto args = duk::get_args<TextAlignment>(ctx);
                        obj->alignment(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "alignment");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto result = obj->angle();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto args = duk::get_args<float>(ctx);
                        obj->angle(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "angle");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto result = obj->color();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto args = duk::get_args<Color>(ctx);
                        obj->color(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "color");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Label>(ctx);
                auto args = duk::get_args<czstring>(ctx);
                obj->font(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "font");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Label>(ctx);
                auto args = duk::get_args<int>(ctx);
                obj->font_size(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "fontSize");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Label>(ctx);
                auto result = obj->height();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "height");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Label>(ctx);
                auto result = obj->length();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "length");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Label>(ctx);
                auto args = duk::get_args<Vec2f>(ctx);
                obj->move(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "move");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto result = obj->position();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto args = duk::get_args<Vec2f>(ctx);
                        obj->position(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "position");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto result = obj->scale();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto args = duk::get_args<float>(ctx);
                        obj->scale(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "scale");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto result = obj->text();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<Label>(ctx);
                        auto args = duk::get_args<czstring>(ctx);
                        obj->text(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "text");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<Label>(ctx);
                auto result = obj->width();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "width");
        duk::push_literal(ctx, "Rainbow.Label");
        duk::put_prop_literal(ctx, -2, DUKR_WELLKNOWN_SYMBOL_TOSTRINGTAG);
    });
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "Label");
}

template <>
void rainbow::duk::register_module<rainbow::SpriteRef>(duk_context* ctx, duk_idx_t rainbow)
{
    duk_push_bare_object(ctx);
    duk::put_prototype<SpriteRef, Allocation::NoHeap>(ctx, [](duk_context* ctx) {
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto result = obj->angle();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto args = duk::get_args<float>(ctx);
                        obj->angle(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "angle");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto result = obj->color();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto args = duk::get_args<Color>(ctx);
                        obj->color(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "color");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                obj->flip();
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "flip");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto result = obj->height();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "height");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                obj->hide();
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "hide");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto result = obj->id();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto args = duk::get_args<int>(ctx);
                        obj->id(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "id");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto result = obj->is_flipped();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "isFlipped");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto result = obj->is_hidden();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "isHidden");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto result = obj->is_mirrored();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "isMirrored");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                obj->mirror();
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "mirror");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto args = duk::get_args<Vec2f>(ctx);
                obj->move(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "move");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto args = duk::get_args<Rect>(ctx);
                obj->normal(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "normal");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto result = obj->pivot();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto args = duk::get_args<Vec2f>(ctx);
                        obj->pivot(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "pivot");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto result = obj->position();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto args = duk::get_args<Vec2f>(ctx);
                        obj->position(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "position");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto args = duk::get_args<float>(ctx);
                obj->rotate(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "rotate");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                switch (duk_get_top(ctx))
                {
                    case 0: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto result = obj->scale();
                        duk::push(ctx, result);
                        return 1;
                    }
                    case 1: {
                        auto obj = duk::push_this<SpriteRef>(ctx);
                        auto args = duk::get_args<Vec2f>(ctx);
                        obj->scale(std::get<0>(args));
                        return 1;
                    }
                    default:
                        duk_push_error_object(ctx, DUK_ERR_SYNTAX_ERROR, "invalid number of arguments");
                        return DUK_RET_SYNTAX_ERROR;
                }
            },
            DUK_VARARGS);
        duk::put_prop_literal(ctx, -2, "scale");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                obj->show();
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "show");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto args = duk::get_args<Rect>(ctx);
                obj->texture(std::get<0>(args));
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "texture");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteRef>(ctx);
                auto result = obj->width();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "width");
        duk::push_literal(ctx, "Rainbow.Sprite");
        duk::put_prop_literal(ctx, -2, DUKR_WELLKNOWN_SYMBOL_TOSTRINGTAG);
    });
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "Sprite");
}

template <>
void rainbow::duk::register_module<rainbow::SpriteBatch>(duk_context* ctx, duk_idx_t rainbow)
{
    duk::push_constructor<SpriteBatch, uint32_t>(ctx);
    duk::put_prototype<SpriteBatch, Allocation::HeapAllocated>(ctx, [](duk_context* ctx) {
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto result = obj->is_visible();
                duk::push(ctx, result);
                return 1;
            },
            0);
        duk::put_prop_literal(ctx, -2, "isVisible");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<graphics::Texture*>(ctx);
                obj->set_normal(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setNormal");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<graphics::Texture*>(ctx);
                obj->set_texture(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setTexture");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<bool>(ctx);
                obj->set_visible(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "setVisible");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                obj->clear();
                return 0;
            },
            0);
        duk::put_prop_literal(ctx, -2, "clear");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<uint32_t, uint32_t>(ctx);
                auto result = obj->create_sprite(std::get<0>(args), std::get<1>(args));
                duk::push(ctx, result);
                return 1;
            },
            2);
        duk::put_prop_literal(ctx, -2, "createSprite");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<uint32_t>(ctx);
                obj->erase(std::get<0>(args));
                return 0;
            },
            1);
        duk::put_prop_literal(ctx, -2, "erase");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<int>(ctx);
                auto result = obj->find_sprite_by_id(std::get<0>(args));
                duk::push(ctx, result);
                return 1;
            },
            1);
        duk::put_prop_literal(ctx, -2, "findSpriteById");
        duk_push_c_function(
            ctx,
            [](duk_context* ctx) -> duk_ret_t {
                auto obj = duk::push_this<SpriteBatch>(ctx);
                auto args = duk::get_args<SpriteRef, SpriteRef>(ctx);
                obj->swap(std::get<0>(args), std::get<1>(args));
                return 0;
            },
            2);
        duk::put_prop_literal(ctx, -2, "swap");
        duk::push_literal(ctx, "Rainbow.SpriteBatch");
        duk::put_prop_literal(ctx, -2, DUKR_WELLKNOWN_SYMBOL_TOSTRINGTAG);
    });
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "SpriteBatch");
}

template <>
void rainbow::duk::register_module<rainbow::TextAlignment>(duk_context* ctx, duk_idx_t rainbow)
{
    const auto obj_idx = duk_push_bare_object(ctx);
    duk_push_int(ctx, to_underlying_type(TextAlignment::Left));
    duk::put_prop_literal(ctx, obj_idx, "Left");
    duk_push_int(ctx, to_underlying_type(TextAlignment::Right));
    duk::put_prop_literal(ctx, obj_idx, "Right");
    duk_push_int(ctx, to_underlying_type(TextAlignment::Center));
    duk::put_prop_literal(ctx, obj_idx, "Center");
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "TextAlignment");
}

template <>
void rainbow::duk::register_module<rainbow::graphics::Texture>(duk_context* ctx, duk_idx_t rainbow)
{
    duk::push_constructor<graphics::Texture, czstring>(ctx);
    duk::put_prototype<graphics::Texture, Allocation::HeapAllocated>(ctx, [](duk_context* ctx) {
        duk::push_literal(ctx, "Rainbow.Texture");
        duk::put_prop_literal(ctx, -2, DUKR_WELLKNOWN_SYMBOL_TOSTRINGTAG);
    });
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "Texture");
}

template <>
void rainbow::duk::register_module<rainbow::VirtualKey>(duk_context* ctx, duk_idx_t rainbow)
{
    const auto obj_idx = duk_push_bare_object(ctx);
    duk_push_int(ctx, to_underlying_type(VirtualKey::Unknown));
    duk::put_prop_literal(ctx, obj_idx, "Unknown");
    duk_push_int(ctx, to_underlying_type(VirtualKey::A));
    duk::put_prop_literal(ctx, obj_idx, "A");
    duk_push_int(ctx, to_underlying_type(VirtualKey::B));
    duk::put_prop_literal(ctx, obj_idx, "B");
    duk_push_int(ctx, to_underlying_type(VirtualKey::C));
    duk::put_prop_literal(ctx, obj_idx, "C");
    duk_push_int(ctx, to_underlying_type(VirtualKey::D));
    duk::put_prop_literal(ctx, obj_idx, "D");
    duk_push_int(ctx, to_underlying_type(VirtualKey::E));
    duk::put_prop_literal(ctx, obj_idx, "E");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F));
    duk::put_prop_literal(ctx, obj_idx, "F");
    duk_push_int(ctx, to_underlying_type(VirtualKey::G));
    duk::put_prop_literal(ctx, obj_idx, "G");
    duk_push_int(ctx, to_underlying_type(VirtualKey::H));
    duk::put_prop_literal(ctx, obj_idx, "H");
    duk_push_int(ctx, to_underlying_type(VirtualKey::I));
    duk::put_prop_literal(ctx, obj_idx, "I");
    duk_push_int(ctx, to_underlying_type(VirtualKey::J));
    duk::put_prop_literal(ctx, obj_idx, "J");
    duk_push_int(ctx, to_underlying_type(VirtualKey::K));
    duk::put_prop_literal(ctx, obj_idx, "K");
    duk_push_int(ctx, to_underlying_type(VirtualKey::L));
    duk::put_prop_literal(ctx, obj_idx, "L");
    duk_push_int(ctx, to_underlying_type(VirtualKey::M));
    duk::put_prop_literal(ctx, obj_idx, "M");
    duk_push_int(ctx, to_underlying_type(VirtualKey::N));
    duk::put_prop_literal(ctx, obj_idx, "N");
    duk_push_int(ctx, to_underlying_type(VirtualKey::O));
    duk::put_prop_literal(ctx, obj_idx, "O");
    duk_push_int(ctx, to_underlying_type(VirtualKey::P));
    duk::put_prop_literal(ctx, obj_idx, "P");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Q));
    duk::put_prop_literal(ctx, obj_idx, "Q");
    duk_push_int(ctx, to_underlying_type(VirtualKey::R));
    duk::put_prop_literal(ctx, obj_idx, "R");
    duk_push_int(ctx, to_underlying_type(VirtualKey::S));
    duk::put_prop_literal(ctx, obj_idx, "S");
    duk_push_int(ctx, to_underlying_type(VirtualKey::T));
    duk::put_prop_literal(ctx, obj_idx, "T");
    duk_push_int(ctx, to_underlying_type(VirtualKey::U));
    duk::put_prop_literal(ctx, obj_idx, "U");
    duk_push_int(ctx, to_underlying_type(VirtualKey::V));
    duk::put_prop_literal(ctx, obj_idx, "V");
    duk_push_int(ctx, to_underlying_type(VirtualKey::W));
    duk::put_prop_literal(ctx, obj_idx, "W");
    duk_push_int(ctx, to_underlying_type(VirtualKey::X));
    duk::put_prop_literal(ctx, obj_idx, "X");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Y));
    duk::put_prop_literal(ctx, obj_idx, "Y");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Z));
    duk::put_prop_literal(ctx, obj_idx, "Z");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number1));
    duk::put_prop_literal(ctx, obj_idx, "Number1");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number2));
    duk::put_prop_literal(ctx, obj_idx, "Number2");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number3));
    duk::put_prop_literal(ctx, obj_idx, "Number3");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number4));
    duk::put_prop_literal(ctx, obj_idx, "Number4");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number5));
    duk::put_prop_literal(ctx, obj_idx, "Number5");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number6));
    duk::put_prop_literal(ctx, obj_idx, "Number6");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number7));
    duk::put_prop_literal(ctx, obj_idx, "Number7");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number8));
    duk::put_prop_literal(ctx, obj_idx, "Number8");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number9));
    duk::put_prop_literal(ctx, obj_idx, "Number9");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Number0));
    duk::put_prop_literal(ctx, obj_idx, "Number0");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Return));
    duk::put_prop_literal(ctx, obj_idx, "Return");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Escape));
    duk::put_prop_literal(ctx, obj_idx, "Escape");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Backspace));
    duk::put_prop_literal(ctx, obj_idx, "Backspace");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Tab));
    duk::put_prop_literal(ctx, obj_idx, "Tab");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Space));
    duk::put_prop_literal(ctx, obj_idx, "Space");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Minus));
    duk::put_prop_literal(ctx, obj_idx, "Minus");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Equals));
    duk::put_prop_literal(ctx, obj_idx, "Equals");
    duk_push_int(ctx, to_underlying_type(VirtualKey::LeftBracket));
    duk::put_prop_literal(ctx, obj_idx, "LeftBracket");
    duk_push_int(ctx, to_underlying_type(VirtualKey::RightBracket));
    duk::put_prop_literal(ctx, obj_idx, "RightBracket");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Backslash));
    duk::put_prop_literal(ctx, obj_idx, "Backslash");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Semicolon));
    duk::put_prop_literal(ctx, obj_idx, "Semicolon");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Apostrophe));
    duk::put_prop_literal(ctx, obj_idx, "Apostrophe");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Grave));
    duk::put_prop_literal(ctx, obj_idx, "Grave");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Comma));
    duk::put_prop_literal(ctx, obj_idx, "Comma");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Period));
    duk::put_prop_literal(ctx, obj_idx, "Period");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Slash));
    duk::put_prop_literal(ctx, obj_idx, "Slash");
    duk_push_int(ctx, to_underlying_type(VirtualKey::CapsLock));
    duk::put_prop_literal(ctx, obj_idx, "CapsLock");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F1));
    duk::put_prop_literal(ctx, obj_idx, "F1");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F2));
    duk::put_prop_literal(ctx, obj_idx, "F2");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F3));
    duk::put_prop_literal(ctx, obj_idx, "F3");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F4));
    duk::put_prop_literal(ctx, obj_idx, "F4");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F5));
    duk::put_prop_literal(ctx, obj_idx, "F5");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F6));
    duk::put_prop_literal(ctx, obj_idx, "F6");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F7));
    duk::put_prop_literal(ctx, obj_idx, "F7");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F8));
    duk::put_prop_literal(ctx, obj_idx, "F8");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F9));
    duk::put_prop_literal(ctx, obj_idx, "F9");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F10));
    duk::put_prop_literal(ctx, obj_idx, "F10");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F11));
    duk::put_prop_literal(ctx, obj_idx, "F11");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F12));
    duk::put_prop_literal(ctx, obj_idx, "F12");
    duk_push_int(ctx, to_underlying_type(VirtualKey::PrintScreen));
    duk::put_prop_literal(ctx, obj_idx, "PrintScreen");
    duk_push_int(ctx, to_underlying_type(VirtualKey::ScrollLock));
    duk::put_prop_literal(ctx, obj_idx, "ScrollLock");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Pause));
    duk::put_prop_literal(ctx, obj_idx, "Pause");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Insert));
    duk::put_prop_literal(ctx, obj_idx, "Insert");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Home));
    duk::put_prop_literal(ctx, obj_idx, "Home");
    duk_push_int(ctx, to_underlying_type(VirtualKey::PageUp));
    duk::put_prop_literal(ctx, obj_idx, "PageUp");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Delete));
    duk::put_prop_literal(ctx, obj_idx, "Delete");
    duk_push_int(ctx, to_underlying_type(VirtualKey::End));
    duk::put_prop_literal(ctx, obj_idx, "End");
    duk_push_int(ctx, to_underlying_type(VirtualKey::PageDown));
    duk::put_prop_literal(ctx, obj_idx, "PageDown");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Right));
    duk::put_prop_literal(ctx, obj_idx, "Right");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Left));
    duk::put_prop_literal(ctx, obj_idx, "Left");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Down));
    duk::put_prop_literal(ctx, obj_idx, "Down");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Up));
    duk::put_prop_literal(ctx, obj_idx, "Up");
    duk_push_int(ctx, to_underlying_type(VirtualKey::NumLock));
    duk::put_prop_literal(ctx, obj_idx, "NumLock");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Divide));
    duk::put_prop_literal(ctx, obj_idx, "KP_Divide");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Multiply));
    duk::put_prop_literal(ctx, obj_idx, "KP_Multiply");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Minus));
    duk::put_prop_literal(ctx, obj_idx, "KP_Minus");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Plus));
    duk::put_prop_literal(ctx, obj_idx, "KP_Plus");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Enter));
    duk::put_prop_literal(ctx, obj_idx, "KP_Enter");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_1));
    duk::put_prop_literal(ctx, obj_idx, "KP_1");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_2));
    duk::put_prop_literal(ctx, obj_idx, "KP_2");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_3));
    duk::put_prop_literal(ctx, obj_idx, "KP_3");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_4));
    duk::put_prop_literal(ctx, obj_idx, "KP_4");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_5));
    duk::put_prop_literal(ctx, obj_idx, "KP_5");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_6));
    duk::put_prop_literal(ctx, obj_idx, "KP_6");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_7));
    duk::put_prop_literal(ctx, obj_idx, "KP_7");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_8));
    duk::put_prop_literal(ctx, obj_idx, "KP_8");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_9));
    duk::put_prop_literal(ctx, obj_idx, "KP_9");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_0));
    duk::put_prop_literal(ctx, obj_idx, "KP_0");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Period));
    duk::put_prop_literal(ctx, obj_idx, "KP_Period");
    duk_push_int(ctx, to_underlying_type(VirtualKey::LessThan));
    duk::put_prop_literal(ctx, obj_idx, "LessThan");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Application));
    duk::put_prop_literal(ctx, obj_idx, "Application");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Power));
    duk::put_prop_literal(ctx, obj_idx, "Power");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KP_Equals));
    duk::put_prop_literal(ctx, obj_idx, "KP_Equals");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F13));
    duk::put_prop_literal(ctx, obj_idx, "F13");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F14));
    duk::put_prop_literal(ctx, obj_idx, "F14");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F15));
    duk::put_prop_literal(ctx, obj_idx, "F15");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F16));
    duk::put_prop_literal(ctx, obj_idx, "F16");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F17));
    duk::put_prop_literal(ctx, obj_idx, "F17");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F18));
    duk::put_prop_literal(ctx, obj_idx, "F18");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F19));
    duk::put_prop_literal(ctx, obj_idx, "F19");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F20));
    duk::put_prop_literal(ctx, obj_idx, "F20");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F21));
    duk::put_prop_literal(ctx, obj_idx, "F21");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F22));
    duk::put_prop_literal(ctx, obj_idx, "F22");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F23));
    duk::put_prop_literal(ctx, obj_idx, "F23");
    duk_push_int(ctx, to_underlying_type(VirtualKey::F24));
    duk::put_prop_literal(ctx, obj_idx, "F24");
    duk_push_int(ctx, to_underlying_type(VirtualKey::LeftCtrl));
    duk::put_prop_literal(ctx, obj_idx, "LeftCtrl");
    duk_push_int(ctx, to_underlying_type(VirtualKey::LeftShift));
    duk::put_prop_literal(ctx, obj_idx, "LeftShift");
    duk_push_int(ctx, to_underlying_type(VirtualKey::LeftAlt));
    duk::put_prop_literal(ctx, obj_idx, "LeftAlt");
    duk_push_int(ctx, to_underlying_type(VirtualKey::LeftSuper));
    duk::put_prop_literal(ctx, obj_idx, "LeftSuper");
    duk_push_int(ctx, to_underlying_type(VirtualKey::RightCtrl));
    duk::put_prop_literal(ctx, obj_idx, "RightCtrl");
    duk_push_int(ctx, to_underlying_type(VirtualKey::RightShift));
    duk::put_prop_literal(ctx, obj_idx, "RightShift");
    duk_push_int(ctx, to_underlying_type(VirtualKey::RightAlt));
    duk::put_prop_literal(ctx, obj_idx, "RightAlt");
    duk_push_int(ctx, to_underlying_type(VirtualKey::RightSuper));
    duk::put_prop_literal(ctx, obj_idx, "RightSuper");
    duk_push_int(ctx, to_underlying_type(VirtualKey::Mode));
    duk::put_prop_literal(ctx, obj_idx, "Mode");
    duk_push_int(ctx, to_underlying_type(VirtualKey::KeyCount));
    duk::put_prop_literal(ctx, obj_idx, "KeyCount");
    duk_freeze(ctx, -1);
    duk::put_prop_literal(ctx, rainbow, "VirtualKey");
}

namespace rainbow::duk
{
    void register_all_modules(duk_context* ctx, duk_idx_t obj_idx)
    {
        duk::register_module<Animation>(ctx, obj_idx);
        duk::register_module<AnimationEvent>(ctx, obj_idx);
        duk::register_module<ControllerAxis>(ctx, obj_idx);
        duk::register_module<ControllerButton>(ctx, obj_idx);
        duk::register_module<Label>(ctx, obj_idx);
        duk::register_module<SpriteRef>(ctx, obj_idx);
        duk::register_module<SpriteBatch>(ctx, obj_idx);
        duk::register_module<TextAlignment>(ctx, obj_idx);
        duk::register_module<graphics::Texture>(ctx, obj_idx);
        duk::register_module<VirtualKey>(ctx, obj_idx);
    }
}

// clang-format on

#ifdef __GNUC__
#    pragma GCC diagnostic pop
#endif

#endif
