// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)

// @ts-check
"use strict";

const fs = require("fs");
const path = require("path");

const COLUMN_LIMIT = 80;
const EOL = "\n";
const INDENT = 8;
const OUTPUT_DIR = path.resolve(__dirname, "..", "src", "Resources");

/**
 * Returns a banner for the specified tool.
 * @param {string} p
 * @returns {string}
 */
function makeBanner(p) {
  const script = path.basename(p).replace(/\.js$/, ".ts");
  return `// This file was generated by \`${script}\`. DO NOT MODIFY!
//
// Copyright (c) 2010-present Bifrost Entertainment AS and Tommy Nguyen
// Distributed under the MIT License.
// (See accompanying file LICENSE or copy at http://opensource.org/licenses/MIT)`;
}

/**
 * Returns a filesystem safe name.
 * @param {string} filename
 * @returns {string}
 */
function makeSafeName(filename) {
  return filename.replace(/[^\w]/g, "_");
}

/**
 * Reads
 * @param {string} asset
 * @returns {Promise<boolean>}
 */
async function importAsset(asset) {
  if (!fs.existsSync(asset)) {
    // eslint-disable-next-line no-console
    console.warn(`No such file: ${asset}`);
    return Promise.resolve(false);
  }

  const stat = fs.statSync(asset);
  if (!stat.isFile()) {
    // eslint-disable-next-line no-console
    console.warn(`Not a file: ${asset}`);
    return Promise.resolve(false);
  }

  /** @type {(resolve: (value: boolean | PromiseLike<Boolean>) => void, reject: (reason?: string) => void) => void} */
  const executor = (resolve, reject) => {
    const filename = path.basename(asset);
    const name = makeSafeName(filename);
    const guard = name.toUpperCase();

    const header = path.join(OUTPUT_DIR, `${filename}.h`);
    const output = fs.createWriteStream(header, { mode: 0o644 });
    output.write(`${makeBanner(__filename)}

#ifndef RESOURCES_${guard}_H_
#define RESOURCES_${guard}_H_

#include <array>
#include <cstdint>

// clang-format off

namespace rainbow::assets
{
    constexpr std::array<uint8_t, ${fs.statSync(asset).size}> k${name}{
${" ".repeat(INDENT)}`);

    const newline = EOL + " ".repeat(INDENT);
    let cursor = INDENT;
    fs.createReadStream(asset)
      .on(
        "data",
        /** @type {(chunk: Buffer) => void} */
        (chunk) =>
          chunk.forEach((byte) => {
            const b = byte.toString();
            if (cursor + b.length >= COLUMN_LIMIT) {
              output.write(newline);
              cursor = INDENT;
            }
            const i = `${b},`;
            output.write(i);
            cursor += i.length;
          })
      )
      .on("end", () => {
        output.end(`
    };
}  // namespace rainbow::assets

// clang-format on

#endif
`);
        resolve(true);

        // eslint-disable-next-line no-console
        console.log(`${asset} -> ${header}`);
      })
      .on(
        "error",
        /** @type {(e: Error) => void} */
        (e) => {
          output.destroy(e);
          reject(e.message);
        }
      );
  };
  return new Promise(executor);
}

/**
 * Asynchronously writes data to a file, replacing the file if needed.
 * @param {string} path
 * @param {string} data
 */
function writeFile(path, data) {
  fs.writeFile(path, data, { encoding: "utf8", mode: 0o644 }, (err) => {
    if (err) {
      throw err;
    }

    // eslint-disable-next-line no-console
    console.log(`-> ${path}`);
  });
}

if (require.main && require.main.filename === __filename) {
  process.argv.slice(process.argv.indexOf(__filename) + 1).forEach(importAsset);
}

module.exports = {
  makeBanner,
  makeSafeName,
  writeFile,
};
